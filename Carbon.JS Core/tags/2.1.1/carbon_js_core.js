/** * Carbon.JS - A simple JavaScript framework * * Carbon.JS Core - CSS1-3 selectors engine * * @author		Dmitry Poluhov <admin@sjs-tech.ru> * @license		http://www.gnu.org/licenses/gpl.html * @version		2.1.1  */ Array.prototype.inArray = function(value) { // Логическое расширение массивов для определения нахождения в них нужных элементов	for (var i = 0; i < this.length; i++) {		if (this[i] === value) return true;	}	return false;};Function.prototype.bind = function(object) { // Расширение функций для передачи им объектов в качестве контекста	var param = this;	return function() {		return param.apply(object, arguments);	}}; var CarbonJS = (function() { // Инициализация пространства имён "CarbonJS"var __regs = [	/^([a-zA-Z0-9]*)#(\w+)(:[^:]+)*$/,	/^([a-zA-Z0-9*]+)?(\.(\w+))?(:[^:]+)*$/,	/^(\w*)(\[(\w+)([=~\|\^\$\*]?)=?"?([^\]"]*)"?\])+(:[^:]+)*$/,	/:?([a-zA-Z\-]+)\(?([a-zA-Z0-9_\.\-\+\*=~\|:\^\$\[\]#"']*)\)?/];function nodeIndex(node) { // Функция возвращает индекс элемента в массиве потомков его родительского элемента	var fs = node.parentNode.firstChild;	var index = 0;	while (fs) {		if (fs.nodeType == 1) {			index++;			if (fs == node) return index;		}		fs = fs.nextSibling;	}}return { // Стандартные методы и свойства CarbonJS	__cache: {}, // Кэш обработанных CSS-селекторов	nodesList: function() { // Возвращает массив элементов, на который навешиваются все методы и свойства типа Q(...).method()		var elements = [];		for (var k in CarbonJS.extend_hash) elements[k] = CarbonJS.extend_hash[k];		elements.concat = function(elems) {			for (var k = 0; k < elems.length; k++) this.push(elems[k]);			return this;		}		return elements;	},	init: function() { // Функция инициализации фреймворка		CarbonJS.extend_hash = {};		CarbonJS.extend = function(hash) {			for (var k in hash) CarbonJS.extend_hash[k] = hash[k];		};		window.Q = function() {			return CarbonJS.get(document, arguments);		};		window.QF = function() {			var args = arguments;			var newargs = [];			for (var i = 1; i < args.length; i++) newargs.push(args[i]);			return CarbonJS.get(args[0], newargs);		};	},	loadModule: function(name, func) { // Функция подгрузки необходимых модулей фреймворка		if (typeof name == "string") {			var compressed = !(name.toUpperCase() == name);			var ns = document.createElement("script");			var nm = "carbon_js_" + name.toLowerCase();			nm += compressed ? "_compressed" : "";			ns.setAttribute("src", nm + ".js");			ns.setAttribute("type", "text/javascript");			ns.setAttribute("id", nm);			Q("head")[0].appendChild(ns);			if (func) {				var module = Q("#" + nm)[0];				module.onreadystatechange = function() {					if (this.readyState == "complete") func();				}				module.onload = function() {					func();				}			}		} else if (typeof name == "object") {			var counter = [];			for (var i = 0; i < name.length; i++) {				var compressed = !(name[i].toUpperCase() == name[i]);				var ns = document.createElement("script");				var nm = "carbon_js_" + name[i].toLowerCase();				nm += compressed ? "_compressed" : "";				ns.setAttribute("src", nm + ".js");				ns.setAttribute("type", "text/javascript");				ns.setAttribute("id", nm);				Q("head")[0].appendChild(ns);				var module = Q("#" + ns.id)[0];				module.onreadystatechange = function() {					if (this.readyState == "complete") counter.push(true);				}				module.onload = function() {					counter.push(true);				}			}			if (func) {				var tm = setInterval(function() {					if (counter.length == name.length) {						clearInterval(tm);						func();					}				}, 10);			}		}	},	modules: { // Свойство, отслеживающее состояние соответствующего модуля - подключён (enabled) или нет (disabled)		core: 		"enabled",		dom: 		"disabled",		animation: 	"disabled",		ui: 		"disabled",		ajax: 		"disabled",		utilities: 	"disabled"	},	get: function(where, selector) { // "Сердце" фреймворка - распределяет разбор переданных ей CSS-селекторов по вспомогательным функциям		var elems = [where];		var params = selector;		var buf = [];		var output = CarbonJS.nodesList();		for (var args = 0; args < params.length; args++) {			if ((params[args] != "undefined" || params[args] != "") && typeof params[args] == "string") {				if (this.__cache[params[args]]) {					buf = this.__cache[params[args]];					elems = [];					for (var i = 0; i < buf.length; i++) elems.push(buf[i]);					buf = [];				} else if (document.querySelectorAll && params[args].indexOf(":contains(") == -1 && params[args].indexOf("!=") == -1 && params[args].indexOf("|=") == -1) {					buf = where.querySelectorAll(params[args]);					elems = [];					for (var i = 0; i < buf.length; i++) elems.push(buf[i]);					buf = [];				} else {					var selectors = params[args].replace(/\s?(>|\+|~)\s?/g, "$1");					var qstr = selectors;					selectors = selectors.split(" ");					for (var i = 0; i < selectors.length; i++) {						if (__regs[0].test(selectors[i])) {							var ch = selectors[i].match(__regs[0]);							elems =	this.getByPseudo(selectors[i], this.getById(ch[1], ch[2]), where);							continue;						} else if (__regs[1].test(selectors[i])) {							var ch = selectors[i].match(__regs[1]);							elems = this.getByPseudo(selectors[i], this.getByTagAndClass(ch[1] || "*", ch[3] || "", elems), where);							continue;						} else if (__regs[2].test(selectors[i])) {							var ch = selectors[i].match(__regs[2]);							elems = this.getByPseudo(selectors[i], this.getByAttrs(ch[1] || "*", selectors[i], elems), where);							continue;						} else if (selectors[i].search(/>|\+|~/) != -1) {							elems = this.getByCombinators(selectors[i], qstr, where);							continue;						}					}					this.__cache[params[args]] = elems;				}				output = output.concat(elems);			} else if ((params[args] != "undefined" || params[args] != "") && typeof params[args] == "object") {				output.push(params[args]);			}			elems = [where];		}		return output;	},	getById: function(tag, id) { // Определение элементов по идентификаторам		if (tag == "") {			return [document.getElementById(id)];		} else {			if (document.getElementById(id).nodeName.toLowerCase() == tag) {				return [document.getElementById(id)];			}		}	},	getByTagAndClass: function(tagName, className, elems) { // Определение элементов по имени тега и CSS-классу		var buf = [];		for (var j = 0; j < elems.length; j++) {			var cur = elems[j].getElementsByTagName(tagName);			for (var k = 0; k < cur.length; k++) {				if (className == "") {					if (!buf.inArray(cur[k])) buf.push(cur[k]);				} else if (className != "" && cur[k].className) {					if (new RegExp("(^|\s)" + className + "(\s|$)").test(cur[k].className) && !buf.inArray(cur[k])) buf.push(cur[k]);				}			}		}		return buf;	},	getByAttrs: function(tag, sels, elems) { // Определение элементов по атрибутам		var buf = [];		var str = sels;		if (str.indexOf(":") != -1) str = str.substring(0, str.indexOf(":"));		var m = str.match(/\[\w+[=~\|\^\$\*]?=?"?[^\]"]*"?\]/g);		for (var j = 0; j < elems.length; j++) {			var cur = elems[j].getElementsByTagName(tag);			for (var k = 0; k < cur.length; k++) {				var check = true;				for (var l = 0; l < m.length; l++) {					var parts = m[l].match(/^\[(\w+)([=~\|\^\$\*]?)=?"?([^\]"]*)"?\]$/);					var an = (parts[1] == "class") ? "className" : parts[1];					var ao = parts[2];					var av = parts[3].replace(/'/g, "");					switch (ao) {						case "=":							if (!(cur[k][an] == av)) check = false;							break;						case "~":							if (!(cur[k][an].match(new RegExp("\\b" + av + "\\b")))) check = false;							break;						case "|":							if (!(cur[k][an].match(new RegExp("^" + av + "-|$")))) check = false;							break;						case "^":							if (!(cur[k][an].match(new RegExp("^" + av)))) check = false;							break;						case "$":							if (!(cur[k][an].match(new RegExp(av + "$")))) check = false;							break;						case "*":							if (!(cur[k][an].indexOf(av) != -1)) check = false;							break;						case "!":							if (!(cur[k][an].indexOf(av) == -1)) check = false;							break;						default:							if (!(cur[k][an])) check = false;					}				}				if (check) buf.push(cur[k]);			}		}		return buf;	},	getByPseudo: function(part, elements, where) { // Определение элементов по псевдо-классам		if (part.indexOf(":") != -1 && __regs[3].test(part.substring(part.indexOf(":"), part.lastIndexOf("")))) {			var nm = part.substring(0, part.indexOf(":"));			part = part.substring(part.indexOf(":"), part.lastIndexOf(""));			var nopc = part.match(/[a-zA-Z\-]+\(?[a-zA-Z0-9_\.\-\+\*=~\|:\^\$\[\]#"']*\)?/g);			for (var i = 0; i < nopc.length; i++) {				var marr = nopc[i].match(__regs[3]);				var buf = [];				var pseudo = marr[1];				var value = marr[2];				switch (pseudo) {					case "first-child":						for (var j = 0; j < elements.length; j++) {							if (elements[j].previousSibling) {								var check = true;								var ps = elements[j];								while (ps = ps.previousSibling) {									if (ps.nodeType == 1) {										check = false;										break;									}								}								if (check) buf.push(elements[j]);							} else {								buf.push(elements[j]);							}						}						break;					case "last-child":						for (var j = 0; j < elements.length; j++) {							if (elements[j].nextSibling) {								var check = true;								var ns = elements[j];								while (ns = ns.nextSibling) {									if (ns.nodeType == 1) {										check = false;										break;									}								}								if (check) buf.push(elements[j]);							} else {								buf.push(elements[j]);							}						}						break;					case "nth-child":						if (/^\d+|even|odd|(-?\d*)n((\+|\-)(\d+))?$/.test(value)) {							if (/^\d+$/.test(value) && value > 0) {								for (var j = 0; j < elements.length; j++) {									var index = 0;									var nc = elements[j].parentNode.firstChild;									while (nc) {										if (nc.nodeType == 1) {											index++;											if (nc == elements[j] && index == value) {												buf.push(elements[j]);												break;											}																					}										nc = nc.nextSibling;									}								}							} else if (/^even|odd$/.test(value)) {								for (var j = 0; j < elements.length; j++) {									var index = 0;									var nc = elements[j].parentNode.firstChild;									while (nc) {										if (nc.nodeType == 1) {											index++;											if ((index % 2 == (value == "even" ? 0 : 1)) && (nc == elements[j])) {												buf.push(elements[j]);												break;											}										}										nc = nc.nextSibling;									}								}							} else if (/^(-?\d*)n((\+|\-)(\d+))?$/.test(value)) {								var val = value.match(/^(-?\d*)n((\+|\-)(\d+))?$/);								var v1 = (val[1] == "-") ? -1 : parseInt(val[1]);	// A/-								var v3 = val[3];									// +/-								var v4 = parseInt(val[4]);							// B								for (var j = 0; j < elements.length; j++) {									if (!val[1] && !val[3] && !val[4]) { // n										var index = 0;										var k = 0;										var nc = elements[j].parentNode.firstChild;										while (nc) {											if (nc.nodeType == 1) {												index++;												if (nc == elements[j]) {													buf.push(elements[j]);													break;												}											}											nc = nc.nextSibling;										}									} else if (!!val[1] && !val[3] && !val[4] && v1 > 0) { // An										var index = 1;										var nc = elements[j].parentNode.firstChild;										while (nc) {											if (nc.nodeType == 1) {												if (nc == elements[j] && index % v1 == 0) {													buf.push(elements[j]);													break;												}												index++;											}											nc = nc.nextSibling;										}									} else if (!val[1] && !!val[3] && !!val[4]) { // n+B										var index = 1;										var nc = elements[j].parentNode.firstChild;										while (nc) {											if (nc.nodeType == 1) {												if (nc == elements[j]) {													if (v3 == "+" && index >= v4) {														buf.push(elements[j]);														break;													} else if (v3 == "-") {														buf.push(elements[j]);														break;													}												}												index++;											}											nc = nc.nextSibling;										}									} else if (!!val[1] && !!val[3] && !!val[4]) { // An+B										var index = 1;										var nc = elements[j].parentNode.firstChild;										while (nc) {											if (nc.nodeType == 1) {												if (nc == elements[j]) {													if (v3 == "+") {														if (v1 < 0) {															if (-index + v4 >= 0) {																buf.push(elements[j]);																break;															}														} else {															if (v1 != 0 && index % v1 == v4) {																buf.push(elements[j]);																break;															} else if (v1 == 0 && index == v4) {																buf.push(elements[j]);																break;															}														}													} else if (v3 == "-") {														if (v1 > 0 && (v4 + index) % v1 == 0) {															buf.push(elements[j]);															break;														}													}												}												index++;											}											nc = nc.nextSibling;										}									}								}							}						}						break;					case "only-child":						for (var j = 0; j < elements.length; j++) {							var nc = elements[j].parentNode.firstChild;							var check = false;							var k = 0;							while (nc && !check) {								if (nc.nodeType == 1) {									k++;									if (k > 1) check = true;								}								nc = nc.nextSibling;							}							if (k == 1 && !check) buf.push(elements[j]);						}						break;					case "root":						buf.push((elements[j].ownerDocument ? elements[j].ownerDocument : document).documentElement);						break;					case "enabled":						buf = elements;						var k = 0;						while (k < buf.length) {							if (!buf[k].disabled) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "disabled":						buf = elements;						var k = 0;						while (k < buf.length) {							if (buf[k].disabled) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "checked":						buf = elements;						var k = 0;						while (k < buf.length) {							if (buf[k].checked) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "selected":						buf = elements;						var k = 0;						while (k < buf.length) {							if (buf[k].selected) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "empty":						buf = elements;						var k = 0;						while (k < buf.length) {							if (buf[k].childNodes.length == 0) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "not":						var badNodes = [];						var t = 0;						var na = [];						if (/^([a-zA-Z0-9*]+)(:[^:]+)*$/.test(value) || /^([a-zA-Z0-9*]+)\.(\w+)(:[^:]+)*$/.test(value)) {							badNodes = QF(where, value);						} else if (/^\.(\w+)(:[^:]+)*$/.test(value) || __regs[2].test(value) || __regs[3].test(value)) {							badNodes = QF(where, nm + value);						}						for (var k = 0; k < elements.length; k++) {							for (var l = 0; l < badNodes.length; l++) {								if (elements[k] == badNodes[l]) t = 1;							}							if (t == 0) {								na.push(elements[k]);							} else {								t = 0;							}						}						buf = na;						break;					case "contains":						for (var j = 0; j < elements.length; j++) {							if (elements[j].innerHTML.indexOf(value) != -1) buf.push(elements[j]);						}						break;				}				elements = buf;			}		}		return elements;	},	getByCombinators: function(sels, qstr, where) { // Определение элементов по CSS-комбинаторам		var buf = [];		var combinators = sels.match(/>|\+|~/g);		var parts = sels.split(/>|\+|~/);		parts.splice(0, 1);		var cqp = qstr.substring(0, qstr.indexOf(sels) + sels.length);		var searchIn = QF(where, cqp.substring(0, cqp.indexOf(combinators[0], cqp.lastIndexOf(" "))));		for (var j = 0; j < parts.length; j++) {			var searchFor = QF(where, parts[j]);			switch (combinators[j]) {				case ">":					for (var k = 0; k < searchIn.length; k++) {						for (var l = 0; l < searchFor.length; l++) {							if (searchFor[l].parentNode == searchIn[k]) buf.push(searchFor[l]);						}					}					return buf;					break;				case "+":					for (var k = 0; k < searchFor.length; k++) {						for (var l = 0; l < searchIn.length; l++) {							var ns = searchIn[l];							while ((ns = ns.nextSibling) && ns.nodeType != 1) {}							if (ns == searchFor[k]) {								buf.push(searchFor[k]);								break;							}						}					}					return buf;					break;				case "~":					for (var k = 0; k < searchFor.length; k++) {						for (var l = 0; l < searchIn.length; l++) {							if (searchFor[k].parentNode == searchIn[l].parentNode) {								if (nodeIndex(searchFor[k]) > nodeIndex(searchIn[l])) {									buf.push(searchFor[k]);									break;								}							}						}					}					return buf;					break;			}		}	}};})();CarbonJS.init(); // Запуск фреймворкаCarbonJS.extend({ // Добавление "цикла" forEach к объекту nodesList для возможности прохода по всем возвращаемым функциями Q и QF элементам	forEach: function(func) {		for (var e = 0; e < this.length; e++) func.apply(this[e], [e]);		return this;	}});