/** * Carbon.JS - A simple JavaScript framework * * Carbon.JS Core - CSS1-3 selectors engine * * @author		Dmitry Polyuhov <admin@carbonjs.com> * @license		http://carbonjs.com/mit-license.txt * @version		2.1.7 (build 20100129) */ /** * inArray method for Arrays * @param {String, Number} value Something to search for in array * @return {Boolean} Returns TRUE, if the option is in the array, and FALSE, if not */ Array.prototype.inArray = function(value) {	var i = 0, ii;	while (ii = this[i++]) {		if (ii === value) return true;	}	return false;};/** * Bind method for Function objects * @param {Object} object Context * @return {Function} */ Function.prototype.bind = function(object) {	var param = this;	return function() {		return param.apply(object, arguments);	}}; /** * Create an anonymous class of Carbon.JS * @ruturn {Object} */var CarbonJS = (function() {/** * Basic regular expression of Carbon.JS */var __regs = [	/^([a-zA-Z0-9]*)#([a-zA-Z0-9-_]+)(:[^:]+)*$/,					// RegExp для определения конструкций вида tag#id	/^([a-zA-Z0-9*]+)?(\.([a-zA-Z0-9-_]+))?(:[^:]+)*$/,				// RegExp для определения конструкций вида tag.class	/^(\w*)(\[(\w+)([=~\|\^\$\*]?)=?"?([^\]"]*)"?\])+(:[^:]+)*$/,	// RegExp для определения конструкций вида E[attr=value]	/:?([a-zA-Z\-]+)\(?([a-zA-Z0-9_\.\-\+\*=~\|:\^\$\[\]#"']*)\)?/	// RegExp для определения псевдоклассов];/** * Function will return index of the element in it's parent's list of children * @param {Node} node Some node * @return {Number} Index of the element */var nodeIndex = function(node) { // Определение порядкового номера элемента в массиве узлов его родительского элемента. Нужно для обработки комбинатора "~"	var fs, index = 0;	if (CarbonJS.traversal) { // При поддержке браузером ElementTraversal API найти нужный элемент можно проще и быстрее,		fs = node.parentNode.firstElementChild; // потому что при этом откидываются текстовые элементы и пр., где nodeType != 1		while (fs && fs != node) {			fs = fs.nextElementSibling;			index++;		}	} else {		fs = node.parentNode.firstChild;		while (fs && fs != node) {			fs = fs.nextSibling;			index++;		}	}	return index;}return {	/**	 * Cache of processed selectors	 */	__cache: {},		/**	 * Add support of Element Traversal API	 */	traversal: typeof document.createElement("div").childElementCount != "undefined", 		/**	 * NodeList of returned elements with all standart methods	 * @return {NodeList}	 */	nodesList: function() { // Каждый возвращённый функциями Q и QF массив является экземпляром объекта nodesList		var elements = [];		for (var k in CarbonJS.extend_hash) elements[k] = CarbonJS.extend_hash[k]; // В нём содержатся не только сами элементы, но и все методы, которые можно к ним применить		elements.concat = function(elems) { // Поскольку nodesList не является чистым массивом, в нём нужно определить стандартную функцию concat для работы в ядре	 			var k = 0, ik;	 			while (ik = elems[k++]) this[this.length] = ik;	 			return this;	 		}		return elements;	},		/**	 * Function of initializing	 */	init: function() {		CarbonJS.extend_hash = {};				/**		 * Add methods to returned NodeList		 * @param {Object} hash Methods that must be added to NodeList		 */		CarbonJS.extend = function(hash) {			for (var k in hash) CarbonJS.extend_hash[k] = hash[k];		};				/**		 * Search elements in document by CSS-selectors		 * @param {Object, String} ... Nodes and strings with CSS-selectors		 * @return {Function}		 * @see CarbonJS.get		 */		window.Q = function() {			return CarbonJS.get(document, arguments); // Q - поиск во всём документе, т.е. контекстом поиска будет объект document		};				/**		 * Search elements in context by CSS-selectors		 * @param {Node} Context to search in		 * @param {Object, String} ... Nodes and strings with CSS-selectors		 * @return {Function}		 * @see CarbonJS.get		 */		window.QF = function() {			var args = arguments;			var newargs = [];			var i = 1, ii;			while (ii = args[i++]) newargs[newargs.length] = ii;	 			return CarbonJS.get(args[0], newargs); // QF - поиск с контекстом, где первым из элементов, переданных функции, является сам контекст		};				var st = Q("script[src*='carbon_js_core']")[0].src; // Определяем путь к ядру Carbon.JS		CarbonJS.url = st.substring(0, st.indexOf("carbon_js_core")); // и записываем его в отдельное свойство	},		/**	 * Check for required modules	 * @param {String} ... Names of required modules	 */	checkModules: function() {		var args = arguments, mm = [];		var i = 0, ii;		while (ii = args[i++]) {			if (!CarbonJS.modules[ii.toLowerCase()]) mm.push(ii);		}		if (mm.length > 0) throw new CarbonJS.Exceptions.ModuleNotFound(mm.join(", "));	},		/**	 * Load different modules of Carbon.JS	 * @author Dmitry Polyuhov (http://carbonjs.com), Aleksandr Michalicyn (http://mihalicyn.ru)	 * @param {String, Array} name Load one module, if String, or several, if Array	 * @param {Function} [func] Callback-function that will execute after loading of all specified modules	 */	loadModules: function(name, func) {		CarbonJS.onDOMready(function() { // Начинаем работать с модулями только после того, как готова DOM			var my_eval = function(source_code) { // Будем использовать вместо стандартного eval для того, чтобы выполнять скрипт в глобальном контексте				if ("\v" != "v") { // В Internet Explorer данное выражение будет истинным					var script = document.createElement("script");					script.type = "text/javascript";					script.appendChild(document.createTextNode(source_code));					document.body.appendChild(script);				} else { // epic fail...					eval(source_code);				}			}			var getXHR = function() { // Перебираем возможные функции для создания XHR-запросов				try {					return new XMLHttpRequest();				} catch (trymicrosoft) {					try {						return new ActiveXObject("Msxml2.XMLHTTP");					} catch (othermicrosoft) {						try {							return new ActiveXObject("Microsoft.XMLHTTP");						} catch (failed) {							throw new CarbonJS.Exceptions.DoesntSupportXHR();						}					}				}			}			var missedModules = [], unknownModules = [], notThrowedExceptions = [];			var loadAndEvalJSFile = function(js_file_name, moduleName) {				var req = getXHR();				req.open("GET", js_file_name, false); // Выполняем синхронный запрос к запрашиваемому файлу				req.send(null);				if (req.status == 200) {					my_eval(req.responseText); // см. объявление функции выше...				} else {					missedModules.push(moduleName);				}			}			if (typeof name == "string") {				var compressed = !(name.toUpperCase() == name); // Если имя запрашиваемого модуля указано заглавными буквами, подключаем Developer-версию, если строчными - обжатую				var nm = "carbon_js_" + name.toLowerCase();				nm += compressed ? "_compressed" : "";				loadAndEvalJSFile(CarbonJS.url + nm + ".js", name);				var nmodule = false;				for (var n in CarbonJS.modules) { // Проверка, существует ли модуль					if (n == name.toLowerCase()) {						nmodule = true;						break;					}				}				if (!nmodule) throw new CarbonJS.Exceptions.UnknownModuleName(name); // Неизвестное имя модуля - кидаем исключение				if (func) func();			} else if (typeof name == "object") {				var i = 0, ii;				while (ii = name[i++]) {					var compressed = !(ii.toUpperCase() == ii);					var nm = "carbon_js_" + ii.toLowerCase();					nm += compressed ? "_compressed" : "";					loadAndEvalJSFile(CarbonJS.url + nm + ".js", ii);					var nmodule = false;					for (var n in CarbonJS.modules) { // Проверка, существует ли модуль						if (n == ii.toLowerCase()) {							nmodule = true;							break;						}					}					if (!nmodule) unknownModules.push(ii);				}				if (unknownModules.length > 0) notThrowedExceptions.push(new CarbonJS.Exceptions.UnknownModuleName(unknownModules.join(", "))); // Неизвестное имя модуля - кидаем исключение				if (missedModules.length > 0) notThrowedExceptions.push(new CarbonJS.Exceptions.ModuleNotFound(missedModules.join(", "))); // Файл модуля не найден - кидаем исключение				if (notThrowedExceptions.length > 1) {					throw new CarbonJS.Exceptions.CombinedException(notThrowedExceptions);				} else if (notThrowedExceptions.length == 1) {					throw notThrowedExceptions[0];				}				if (func) func();			}		});	},		/**	 * Current statuses of basic modules	 */	modules: { // Параметр modules объекта CarbonJS позволяет отслеживать состояние каждого модуля, чтобы избежать ошибок из-за нехватки какого-либо модуля		core: 		true,		dom: 		false,		animation: 	false,		ui: 		false,		ajax: 		false,		utilities: 	false	},		/**	 * Possible exceptions of the framework	 */	Exceptions: {		ModuleNotFound: function(moduleName) { // Исключение - модуль не найден. Вызывается, когда запрашиваемый модуль отсутствует в папке, где находится ядро			this.name = "Carbon.JS Error";			this.message = "Missing module(s) - \"" + moduleName + "\"";			this.toString = function() {				return this.name + ": " + this.message;			}		},		UnknownModuleName: function(moduleName) { // Исключение - неизвестное имя модуля. Вызывается, когда имя запрашиваемого модуля написано неправильно. Например: utilites вместо utilities			this.name = "Carbon.JS Error";			this.message = "Unknown name of module(s) - \"" + moduleName + "\"";			this.toString = function() {				return this.name + ": " + this.message;			}		},		NodeListIsEmpty: function(queryName) { // Исключение - не найдены элементы при использовании Q и QF. Вызывается, когда к пустому списку элементов применяется какая-либо функция, подрузумевающая работу с этими элементами			this.name = "Carbon.JS Error";			this.message = "Returned by the \"" + queryName + "\"-query NodeList is empty";			this.toString = function() {				return this.name + ": " + this.message;			}		},		MissingElement: function(queryName) { // Исключение - запрашиваемый элемент отсутствует в списке полученных узлов			this.name = "Carbon.JS Error";			this.message = "The element that you requested from the \"" + queryName + "\"-query is not listed";			this.toString = function() {				return this.name + ": " + this.message;			}		},		DoesntSupportXHR: function() { // Исключение - невозможно создать XHR-запрос. Вызывается в устаревших браузерах, не поддерживающих XHR-запросы			this.name = "Carbon.JS Error";			this.message = "Your web-browser doesn't support XHR-requests";			this.toString = function() {				return this.name + ": " + this.message;			}		},		CombinedException: function(exceptions_array) { // Для вывода нескольких исключений сразу			this.name = "Carbon.JS Error";			this.message = "Some exceptions were throwed:\n";			for (var i = 0; i < exceptions_array.length; i++) this.message += exceptions_array[i].toString() + "\n";			this.toString = function() {				return this.name + ": " + this.message;			}		}	},		/**	 * Main function of getting elements by CSS-selectors	 * @param {Node} where Context to search in	 * @param {Array} selector Array of input selectors and nodes	 * @return {NodeList} NodeList of elements with all basic methods	 */	get: function(where, selector) {		var elems = [where];		var params = selector;		var buf = [];		var output = CarbonJS.nodesList(); // Для каждого запроса создаём новый экземпляр nodesList		var args = 0, iargs;		while (iargs = params[args++]) {			if (typeof iargs == "string") { // Если передана строка с селекторами, то едем дальше				if (this.__cache[iargs]) { // Проверяем кэш на соответствие уже обработанных запросов новому					buf = this.__cache[iargs];					elems = [];					var i = 0, ii;					while (ii = buf[i++]) elems[elems.length] = ii;					buf = [];				} else if (document.querySelectorAll) { // Проверяем, поддерживает ли браузер querySelectorAll API					try { // В Google Chrome и Apple Safari в некоторых случаях при поиске необходимых строк ввода (input) выскакивает DOM Exception, а IE 8 не понимает некоторые селекторы						buf = where.querySelectorAll(iargs);						elems = [];						var i = 0, ii;						while (ii = buf[i++]) elems[elems.length] = ii;						buf = [];					} catch(e) { // Поэтому, если в querySelectorAll проскакивает исключение, переводим обработку селекторов на сам Carbon.JS						var selectors = iargs.replace(/\s?(>|\+|~)\s?/g, "$1");						var qstr = selectors;						selectors = selectors.split(" ");						var i = 0, ii;						while (ii = selectors[i++]) { // Далее перенаправляем соответствующего типа селекторы на обработку в соответствующие им функции							if (ii.search(/>|\+[^0-9][^\)]?|~[^=]/) != -1) {								elems = this.getByCombinators(ii, qstr, where);								continue;							}							if (__regs[0].test(ii)) {								var ch = ii.match(__regs[0]);								elems =	this.getByPseudo(ii, this.getById(ch[1], ch[2]), where);								continue;							} else if (__regs[1].test(ii)) {								var ch = ii.match(__regs[1]);								elems = this.getByPseudo(ii, this.getByTagAndClass(ch[1] || "*", ch[3] || "", elems, (i == selectors.length)), where);								continue;							} else if (__regs[2].test(ii)) {								var ch = ii.match(__regs[2]);								elems = this.getByPseudo(ii, this.getByAttrs(ch[1] || "*", ii, elems), where);								continue;							}						}					}					this.__cache[iargs] = elems;				} else { // Если кэш пуст, а querySelectorAll не поддерживается, обрабатываем селекторы самой библиотекой					var selectors = iargs.replace(/\s?(>|\+|~)\s?/g, "$1");					var qstr = selectors;					selectors = selectors.split(" ");					var i = 0, ii;					while (ii = selectors[i++]) {						if (ii.search(/>|\+[^0-9][^\)]?|~[^=]/) != -1) {							elems = this.getByCombinators(ii, qstr, where);							continue;						}						if (__regs[0].test(ii)) {							var ch = ii.match(__regs[0]);							elems =	this.getByPseudo(ii, this.getById(ch[1], ch[2]), where);							continue;						} else if (__regs[1].test(ii)) {							var ch = ii.match(__regs[1]);							elems = this.getByPseudo(ii, this.getByTagAndClass(ch[1] || "*", ch[3] || "", elems, (i == selectors.length)), where);							continue;						} else if (__regs[2].test(ii)) {							var ch = ii.match(__regs[2]);							elems = this.getByPseudo(ii, this.getByAttrs(ch[1] || "*", ii, elems), where);							continue;						}					}					this.__cache[iargs] = elems; // Полученные элементы и соответствующие им селекторы помещаем в кэш				}				output = output.concat(elems);			} else if (typeof iargs == "object") {				output[output.length] = iargs;			}			elems = [where];		}		output.qstr = selector.length == 1 ? selector[0] : Array.prototype.join.call(selector, ", ");		return output;	},		/**	 * Get elements by id	 * @param {String} tag	 * @param {String} id	 * @return {Node}	 */	getById: function(tag, id) {		if (tag == "") { // Если ищится элемент по id, просто возвращаем ссылку на него			return [document.getElementById(id)];		} else {			if (document.getElementById(id).nodeName.toLowerCase() == tag) { // Если ищится конкретный тег с определённым id, то проверяем имя элемента с нашим id на соответствие имени нужного тега				return [document.getElementById(id)];			}		}	},		/**	 * Get elements by tag and class	 * @param {String} tagName	 * @param {String} className	 * @param {NodeList} elems	 * @return {NodeList}	 */	getByTagAndClass: function(tagName, className, elems, le) {		var buf = [];		var j = 0, ij;		if (document.getElementsByClassName && className != "") { // Если поддерживается getElementsByClassName API,			while (ij = elems[j++]) {				var byClass = ij.getElementsByClassName(className), k = 0, ik; // то можно быстро получить все элементы с нужным классом				while (ik = byClass[k++]) {					if (tagName != "*" && ik.nodeName.toLowerCase() == tagName && !ik.added) { // В некоторых случаях в конечном массиве nodesList могут оказаться несколько одинаковых элементов						if (le) ik.added = true; // Чтобы этого не произошло, помечаем уже добавленные элементы						buf[buf.length] = ik;					} else if (tagName == "*") buf[buf.length] = ik;				}			}		} else { // Если getElementsByClassName не поддерживается,			while (ij = elems[j++]) {				var cur = ij.getElementsByTagName(tagName), k = 0, ik; // то получаем коллекцию всех указанных тегов и проверяем их className на соответствие нашему классу				while (ik = cur[k++]) {					if (className == "" && !ik.added) {						if (le) ik.added = true;						buf[buf.length] = ik;					} else if (className != "" && ik.className) {						if (new RegExp("(^|\s)" + className + "(\s|$)").test(ik.className) && !ik.added) {							if (le) ik.added = true;							buf[buf.length] = ik;						}					}				}			}		}		var len = buf.length;		while (len--) buf[len].added = null; // После того, как все элементы определены, удаляем у них метку о том, что они уже были добавлены		return buf;	},		/**	 * Get elements by attributes	 * @param {String} tag	 * @param {String} sels	 * @param {NodeList} elems	 * @return {NodeList}	 */	getByAttrs: function(tag, sels, elems) {		var buf = [];		var str = sels;		if (str.indexOf(":") != -1) str = str.substring(0, str.indexOf(":"));		var m = str.match(/\[\w+[=~\|\^\$\*]?=?"?[^\]"]*"?\]/g); // Расчлением исходную строку с селекторами на конструкции вида [attr=value]		var j = 0, ij;		while (ij = elems[j++]) {			var cur = ij.getElementsByTagName(tag);			var k = 0, ik;			while (ik = cur[k++]) {				var check = true;				var l = 0, il;				while (il = m[l++]) {					var parts = il.match(/^\[(\w+)([=~\|\^\$\*]?)=?"?([^\]"]*)"?\]$/); // Потом, работая с каждым элементом по отдельности, расчлением каждую такую конструкцию на составляющие					var an = (parts[1] == "class") ? "className" : parts[1]; // Атрибут					var ao = parts[2]; // Сравнение					var av = parts[3].replace(/'/g, ""); // Свойство					switch (ao) {						case "=":							if (ik[an] != av) check = false; // Значение атрибута точно соответствует значению							break;						case "~":							if (!ik[an].match(new RegExp("\\b" + av + "\\b"))) check = false; // Значение атрибута является списком разделённых пробелами значений, одно из которых соответствует нашему							break;						case "|":							if (!ik[an].match(new RegExp("^" + av + "-|$"))) check = false; // Значение атрибута является списком разделённых символом "-" значений, первое из которых (слева) соответствует искомому							break;						case "^":							if (!ik[an].match(new RegExp("^" + av))) check = false; // Значение атрибута начинается с нашего строкового свойства							break;						case "$":							if (!ik[an].match(new RegExp(av + "$"))) check = false; // Значение атрибута заканчивается нашим строковым свойством							break;						case "*":							if (ik[an].indexOf(av) == -1) check = false; // Значение атрибута содержит в себе наше строковое свойство							break;						case "!":							if (ik[an].indexOf(av) != -1) check = false; // Значение атрибута не содержит в себе наше строковое свойство							break;						default:							if (!ik[an]) check = false; // Просто проверка на наличие атрибута					}				}				if (check) buf[buf.length] = ik;			}		}		return buf;	},		/**	 * Get elements by pseudo-classes	 * @param {String} part	 * @param {NodeList} elements	 * @param {Node} where	 * @return {NodeList}	 */	getByPseudo: function(part, elements, where) {		if (part.indexOf(":") != -1 && __regs[3].test(part.substring(part.indexOf(":"), part.lastIndexOf("")))) {			var nm = part.substring(0, part.indexOf(":"));			part = part.substring(part.indexOf(":"), part.lastIndexOf(""));			var nopc = part.match(/[a-zA-Z\-]+\(?[a-zA-Z0-9_\.\-\+\*=~\|:\^\$\[\]#"']*\)?/g); // Так же, как и в предыдущей функции, расчленяем псевдоклассы на составляющие			var i = 0, ii;			while (ii = nopc[i++]) {				var marr = ii.match(__regs[3]);				var buf = [];				var pseudo = marr[1]; // Тип псевдокласса				var value = marr[2]; // Значение, указанное в скобках				switch (pseudo) {					case "first-child": // Элемент является первым ребёнком своего родительского элемента						var j = 0, ij;						while (ij = elements[j++]) { // Для этого проходим все полученные на данный момент элементы							if (ij.previousSibling) { // Если перед ними на одном иерархическом уровне есть какой-то сестринский элемент,								var check = true;								var ps = ij;								while (ps = ps.previousSibling) { // то проверяем, текстовый это элемент или нет									if (ps.nodeType == 1) { // Если nodeType предыдущего сестринского элемента равен 1, то это полноценный узел,										check = false; // и, значит, наш элемент не подходит										break;									}								}								if (check) buf[buf.length] = ij;							} else { // А если предыдущего сестринского элемента нет - значит наш элемент точно подходит								buf[buf.length] = ij;							}						}						break;					case "last-child": // То же самое, что и first-child, только не первый элемент, а последний						var j = 0, ij;						while (ij = elements[j++]) {							if (ij.nextSibling) {								var check = true;								var ns = ij;								while (ns = ns.nextSibling) {									if (ns.nodeType == 1) {										check = false;										break;									}								}								if (check) buf[buf.length] = ij;							} else {								buf[buf.length] = ij;							}						}						break;					case "nth-child": // Проверка на удовлетворение порядкового номера элемента в списке дочерних элементов его родителя нашему условию						if (/^\d+|even|odd|(-?\d*)n((\+|\-)(\d+))?$/.test(value)) {							if (value == "even") { // Алгоритм работает с комбинациями типа an+b,								value = "2n"; // поэтому перенаправляем текстовые значения на соответствующие им комбинации							} else if (value == "odd") {								value = "2n+1";							}							var val = value.match(/([+-]?\d)*(n)([+-]\d+)*/), a, b;							if (val) { // Расчленияем полученное выражение на составляющие								a = parseInt(val[1], 10) || 0;								b = parseInt(val[3], 10) || 0;							}							if (/^\+n|^n/.test(value)) {								a = 1;							} else if (/^-n/.test(value)) {								a = -1;							}							var j = 0, ij;							while (ij = elements[j++]) {								if (!ij.nodeIndex) {									var node = ij.parentNode.firstChild, count = 0;									while (node) {										if (node.nodeType == 1) node.nodeIndex = ++count;										node = node.nextSibling;									}								}								var position = ij.nodeIndex;								if ((!a && !b && position == value) || (a == 0 ? position == b : a > 0 ? position >= b && (position - b) % a == 0 : position <= b && (b - position) % a == 0)) buf[buf.length] = ij;							}						}						break;					case "only-child": // Проверка того, что наш элемент является единственным дочерним элементом своего родительского узла						var j = 0, ij;						while (ij = elements[j++]) { // Принцип обработки такой же, как и у предыдущих псевдоклассов							var nc = ij.parentNode.firstChild;							var check = false;							var k = 0;							while (nc && !check) {								if (nc.nodeType == 1) {									k++;									if (k > 1) check = true;								}								nc = nc.nextSibling;							}							if (k == 1 && !check) buf[buf.length] = ij;						}						break;					case "enabled": // Отсеиваем все "разрешённые" к взаимодействию с пользователем элементы (пример - чекбокс, в котором можно поставить галочку)						buf = elements;						var k = 0;						while (k < buf.length) {							if (!buf[k].disabled) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "disabled": // Отсеиваем все "отключённые" элементы, т.е. те элементы, с которыми нельзя будет взаимодействовать (пример - заблокированная кнопка, на которую нельзя нажать)						buf = elements;						var k = 0;						while (k < buf.length) {							if (buf[k].disabled) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "checked": // Обычно используют для отсеивания выбранных чекбоксов						buf = elements;						var k = 0;						while (k < buf.length) {							if (buf[k].checked) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "selected": // "Выбранные" элементы (обычно тег <option>)						buf = elements;						var k = 0;						while (k < buf.length) {							if (buf[k].selected) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "empty": // Поиск пустых элементов, т.е. у которых нет дочерних узлов						buf = elements;						var k = 0;						while (k < buf.length) {							if (buf[k].childNodes.length == 0) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "not": // Псевдокласс для нахождения элементов, которые не удовлетворяют заданному условию						var badNodes = [];						var t = 0;						var na = [];						if (/^([a-zA-Z0-9*]+)(:[^:]+)*$/.test(value) || /^([a-zA-Z0-9*]+)\.(\w+)(:[^:]+)*$/.test(value)) {							badNodes = QF(where, value);						} else if (/^\.(\w+)(:[^:]+)*$/.test(value) || __regs[2].test(value) || __regs[3].test(value)) {							badNodes = QF(where, nm + value);						}						var k = 0, ik;						while (ik = elements[k++]) { // Действуем от противного - выбираем элементы, которые удовлетворяют заданному условию и "вычитаем" их из уже найденных обычных							var l = 0, il;							while (il = badNodes[l++]) {								if (ik == il) t = 1;							}							if (t == 0) {								na[na.length] = ik;							} else {								t = 0;							}						}						buf = na;						break;					case "contains": // Проверка узла на наличие в нём заданной строки						var j = 0, ij;						while (ij = elements[j++]) {							if (ij.innerHTML.indexOf(value) != -1) buf[buf.length] = ij;						}						break;				}				elements = buf;			}		}		return elements;	},		/**	 * Get elements by combinators	 * @param {String} sels	 * @param {String} qstr	 * @param {Node} where	 * @return {NodeList}	 */	getByCombinators: function(sels, qstr, where) {		var buf = [];		var combinators = sels.match(/>|~|\+(?![0-9)])/g); // Получаем список используемых в запросе комбинаторов		var parts = sels.split(/>|~|\+(?![0-9)])/); // Потом получаем селекторы, находящиеся между этими комбинаторами		parts.splice(0, 1);		var cqp = qstr.substring(0, qstr.indexOf(sels) + sels.length);		var searchIn = QF(where, cqp.substring(0, cqp.indexOf(combinators[0], cqp.lastIndexOf(" ")))); // После некоторых преобразований получаем массив элементов, в которых будет производиться поиск последующих узлов		var j = 0, ij;		while (ij = parts[j++]) { // Обрабатываем каждый комбинатор отдельно			var searchFor = QF(where, ij); // Ищим по селектору, идущему после очередного комбинатора			switch (combinators[j - 1]) {				case ">": // Элемент является прямым потомком своего родительского узла					if (buf.length > 0) {						searchIn = buf;					} else {						if (parts[j - 2]) searchIn = QF(where, parts[j - 2])					}					buf = [];					var k = 0, ik;					while (ik = searchIn[k++]) {						var l = 0, il;						while (il = searchFor[l++]) {							if (il.parentNode == ik) buf[buf.length] = il; // Перебираем все узлы на соответствие родительского элемента и узла, в котором мы ищем наш элемент						}					}					if (buf.length == 0) return [];					break;				case "+": // Элементы находятся на одном иерархическом уровне и являются прямыми сестринскими элементами					if (buf.length > 0) {						searchIn = buf;					} else {						if (parts[j - 2]) searchIn = QF(where, parts[j - 2])					}					buf = [];					var k = 0, ik;					if (CarbonJS.traversal) { // Если поддерживается ElementTraversal API, то можно не тратить лишние ресурсы на определение типа узла						while (ik = searchFor[k++]) {							var l = 0, il;							while (il = searchIn[l++]) {								if (il.nextElementSibling == ik) {									buf[buf.length] = ik;									break;								}							}						}					} else {						while (ik = searchFor[k++]) {							var l = 0, il;							while (il = searchIn[l++]) {								var ns = il;								while ((ns = ns.nextSibling) && ns.nodeType != 1) {} // Здесь мы не только ищем следующий сестринский элемент, но также и проверяем тип узла								if (ns == ik) {									buf[buf.length] = ik;									break;								}							}						}					}					if (buf.length == 0) return [];					break;				case "~": // Элементы являются не прямыми сестринскиими элементами					if (buf.length > 0) {						searchIn = buf;					} else {						if (parts[j - 2]) searchIn = QF(where, parts[j - 2])					}					buf = [];					var k = 0, ik;					while (ik = searchFor[k++]) {						var l = 0, il;						while (il = searchIn[l++]) {							if (ik.parentNode == il.parentNode) {								if (nodeIndex(ik) > nodeIndex(il)) { // Для этого нужно сравнивать порядковые номера узлов в списке потомков их родительского элемента									buf[buf.length] = ik; // Поэтому обработка этого комбинатора является самой ресурсоёмкой									break;								}							}						}					}					if (buf.length == 0) return [];					break;			}		}		return buf;	}};})();/** * Initialize Carbon.JS */CarbonJS.init();CarbonJS.extend({	/**	 * forEach-loop for NodeList	 * @param {Function} func	 * @return {NodeList}	 */	forEach: function(func) {		var e = 0, ie;		while (ie = this[e++]) func.apply(ie, [e - 1]); // Передаём ссылку на каждый элемент и его индекс в массиве узлов		return this;	},		/**	 * Get element by it's index in NodeList	 * @param {Number} ind	 * @return {Node}	 */	item: function(ind) {		if (this.length == 0) {			throw new CarbonJS.Exceptions.NodeListIsEmpty(this.qstr);		} else {			if (this[ind]) {				return Q(this[ind]);			} else {				throw new CarbonJS.Exceptions.MissingElement(this.qstr);			}		}	}});/** * This function executes all received functions after the creation of DOM * @author Dean Edwards (http://dean.edwards.name) * @param {Function} newfunc */CarbonJS.onDOMready = function(func) {	var init = function() {		if (arguments.callee.done) return; // Чтобы не вызывать повторно уже вызванную функцию,		arguments.callee.done = true; // записываем в неё специальное свойство		if (_timer) {			clearInterval(_timer);			_timer = null;		}		func();	};	if (document.addEventListener) document.addEventListener("DOMContentLoaded", init, false); // Нормальные браузеры поддерживают родной обработчик события  - создания DOM	// В браузерах IE это событие можно отследить, если создать специальные тег script, у которого отложено выполнение	/*@cc_on @*/	/*@if (@_win32)		document.write("<script id=__ie_onload defer src=javascript:void(0)><\/script>");		var script = document.getElementById("__ie_onload");		script.onreadystatechange = function() {			if (this.readyState == "complete") init();		};	/*@end @*/	if (/WebKit/i.test(navigator.userAgent)) { // В браузерах Apple Safari и Google Chrome можно отслеживать свойство readyState объекта document		var _timer = setInterval(function() {			if (/loaded|complete/.test(document.readyState)) init();		}, 10);	}	window.onload = init; // Если описанные выше методы не поддерживаются, вешаем исполнение функции на onload};