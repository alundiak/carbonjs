/** * Carbon.JS - A simple JavaScript framework * * Carbon.JS Core - CSS1-3 selectors engine * * @author		Dmitry Poluhov <admin@sjs-tech.ru> * @license		http://www.gnu.org/licenses/gpl.html * @version		2.1.3 (build 20090419) */ /** * inArray method for Arrays * @param {String, Number} value Something to search for in array * @return {Boolean} Returns TRUE, if the option is in the array, and FALSE, if not */ Array.prototype.inArray = function(value) {	var i = -1;	while (++i < this.length) {		if (this[i] === value) return true;	}	return false;};/** * Bind method for Function objects * @param {Object} object Context * @return {Function} */ Function.prototype.bind = function(object) {	var param = this;	return function() {		return param.apply(object, arguments);	}}; /** * Create an anonymous class of Carbon.JS * * @constructor * @ruturn {Object} */var CarbonJS = (function() {/** * Basic regular expression of Carbon.JS */var __regs = [	/^([a-zA-Z0-9]*)#(\w+)(:[^:]+)*$/,	/^([a-zA-Z0-9*]+)?(\.(\w+))?(:[^:]+)*$/,	/^(\w*)(\[(\w+)([=~\|\^\$\*]?)=?"?([^\]"]*)"?\])+(:[^:]+)*$/,	/:?([a-zA-Z\-]+)\(?([a-zA-Z0-9_\.\-\+\*=~\|:\^\$\[\]#"']*)\)?/];/** * Function will return index of the element in it's parent's list of children * @param {Node} node Some node * @return {Number} Index of the element */function nodeIndex(node) {	var fs = node.parentNode.firstChild;	var index = 0;	while (fs && fs != node) {		fs = fs.nextSibling;		index++;	}	return index;}return {	/**	 * Cache of processed selectors	 */	__cache: {},		/**	 * Add support of Element Traversal API	 */	traversal: typeof document.createElement("div").childElementCount != "undefined", 		/**	 * NodeList of returned elements with all standart methods	 * @constructor	 * @return {NodeList}	 */	nodesList: function() {		var elements = [];		for (var k in CarbonJS.extend_hash) elements[k] = CarbonJS.extend_hash[k];		elements.concat = function(elems) {			var k = -1;			while (++k < elems.length) this[this.length] = elems[k];			return this;		}		return elements;	},		/**	 * Function of initializing	 */	init: function() {		CarbonJS.extend_hash = {};				/**		 * Add methods to returned NodeList		 * @param {Object} hash Methods that must be added to NodeList		 */		CarbonJS.extend = function(hash) {			for (var k in hash) CarbonJS.extend_hash[k] = hash[k];		};				/**		 * Search elements in document by CSS-selectors		 *		 * @constructor		 * @param {Object, String} ... Nodes and strings with CSS-selectors		 * @return {Function}		 * @see get		 */		window.Q = function() {			return CarbonJS.get(document, arguments);		};				/**		 * Search elements in context by CSS-selectors		 *		 * @constructor		 * @param {Node} Context to search in		 * @param {Object, String} ... Nodes and strings with CSS-selectors		 * @return {Function}		 * @see get		 */		window.QF = function() {			var args = arguments;			var newargs = [];			var i = 0;			while (++i < args.length) newargs[newargs.length] = args[i];			return CarbonJS.get(args[0], newargs);		};	},		/**	 * Load different modules of Carbon.JS	 * @param {String, Array} name Load one module, if String, or several, if Array	 * @param {Function} [func] Callback-function that will execute after loading of all specified modules	 */	loadModule: function(name, func) {		if (typeof name == "string") {			var compressed = !(name.toUpperCase() == name);			var ns = document.createElement("script");			var nm = "carbon_js_" + name.toLowerCase();			nm += compressed ? "_compressed" : "";			ns["src"] = nm + ".js";			ns["type"] = "text/javascript";			ns["id"] = nm;			Q("head")[0].appendChild(ns);			if (func) {				var module = Q("#" + nm)[0];				module.onreadystatechange = function() {					if (this.readyState == "complete") func();				}				module.onload = function() {					func();				}			}		} else if (typeof name == "object") {			var counter = [];			var i = -1;			while (++i < name.length) {				var compressed = !(name[i].toUpperCase() == name[i]);				var ns = document.createElement("script");				var nm = "carbon_js_" + name[i].toLowerCase();				nm += compressed ? "_compressed" : "";				ns["src"] = nm + ".js";				ns["type"] = "text/javascript";				ns["id"] = nm;				Q("head")[0].appendChild(ns);				var module = Q("#" + ns.id)[0];				module.onreadystatechange = function() {					if (this.readyState == "complete") counter[counter.length] = true;				}				module.onload = function() {					counter[counter.length] = true;				}			}			if (func) {				var tm = setInterval(function() {					if (counter.length == name.length) {						clearInterval(tm);						func();					}				}, 10);			}		}	},		/**	 * Current statuses of basic modules	 */	modules: {		core: 		"enabled",		dom: 		"disabled",		animation: 	"disabled",		ui: 		"disabled",		ajax: 		"disabled",		utilities: 	"disabled"	},		/**	 * Main function of getting elements by CSS-selectors	 * @param {Node} where Context to search in	 * @param {Array} selector Array of input selectors and nodes	 * @return {NodeList} NodeList of elements with all basic methods	 */	get: function(where, selector) {		var elems = [where];		var params = selector;		var buf = [];		var output = CarbonJS.nodesList();		var args = -1;		while (++args < params.length) {			if ((params[args] != "undefined" || params[args] != "") && typeof params[args] == "string") {				if (this.__cache[params[args]]) {					buf = this.__cache[params[args]];					elems = [];					var i = -1;					while (++i < buf.length) elems[elems.length] = buf[i];					buf = [];				} else if (document.querySelectorAll) {					try {						buf = where.querySelectorAll(params[args]);						elems = [];						var i = -1;						while (++i < buf.length) elems[elems.length] = buf[i];						buf = [];					} catch(e) {						var selectors = params[args].replace(/\s?(>|\+|~)\s?/g, "$1");						var qstr = selectors;						selectors = selectors.split(" ");						var i = -1;						while (++i < selectors.length) {							if (__regs[0].test(selectors[i])) {								var ch = selectors[i].match(__regs[0]);								elems =	this.getByPseudo(selectors[i], this.getById(ch[1], ch[2]), where);								continue;							} else if (__regs[1].test(selectors[i])) {								var ch = selectors[i].match(__regs[1]);								elems = this.getByPseudo(selectors[i], this.getByTagAndClass(ch[1] || "*", ch[3] || "", elems), where);								continue;							} else if (__regs[2].test(selectors[i])) {								var ch = selectors[i].match(__regs[2]);								elems = this.getByPseudo(selectors[i], this.getByAttrs(ch[1] || "*", selectors[i], elems), where);								continue;							} else if (selectors[i].search(/>|\+|~/) != -1) {								elems = this.getByCombinators(selectors[i], qstr, where);								continue;							}						}					}					this.__cache[params[args]] = elems;				} else {					var selectors = params[args].replace(/\s?(>|\+|~)\s?/g, "$1");					var qstr = selectors;					selectors = selectors.split(" ");					var i = -1;					while (++i < selectors.length) {						if (__regs[0].test(selectors[i])) {							var ch = selectors[i].match(__regs[0]);							elems =	this.getByPseudo(selectors[i], this.getById(ch[1], ch[2]), where);							continue;						} else if (__regs[1].test(selectors[i])) {							var ch = selectors[i].match(__regs[1]);							elems = this.getByPseudo(selectors[i], this.getByTagAndClass(ch[1] || "*", ch[3] || "", elems), where);							continue;						} else if (__regs[2].test(selectors[i])) {							var ch = selectors[i].match(__regs[2]);							elems = this.getByPseudo(selectors[i], this.getByAttrs(ch[1] || "*", selectors[i], elems), where);							continue;						} else if (selectors[i].search(/>|\+|~/) != -1) {							elems = this.getByCombinators(selectors[i], qstr, where);							continue;						}					}					this.__cache[params[args]] = elems;				}				output = output.concat(elems);			} else if ((params[args] != "undefined" || params[args] != "") && typeof params[args] == "object") {				output[output.length] = params[args];			}			elems = [where];		}		return output;	},		/**	 * Get elements by id	 * @param {String} tag	 * @param {String} id	 * @return {Node}	 */	getById: function(tag, id) {		if (tag == "") {			return [document.getElementById(id)];		} else {			if (document.getElementById(id).nodeName.toLowerCase() == tag) {				return [document.getElementById(id)];			}		}	},		/**	 * Get elements by tag and class	 * @param {String} tagName	 * @param {String} className	 * @param {NodeList} elems	 * @return {NodeList}	 */	getByTagAndClass: function(tagName, className, elems) {		var buf = [];		var j = -1;		while (++j < elems.length) {			var cur = elems[j].getElementsByTagName(tagName);			var k = -1;			while (++k < cur.length) {				if (className == "") {					if (!buf.inArray(cur[k])) buf[buf.length] = cur[k];				} else if (className != "" && cur[k].className) {					if (new RegExp("(^|\s)" + className + "(\s|$)").test(cur[k].className) && !buf.inArray(cur[k])) buf[buf.length] = cur[k];				}			}		}		return buf;	},		/**	 * Get elements by attributes	 * @param {String} tag	 * @param {String} sels	 * @param {NodeList} elems	 * @return {NodeList}	 */	getByAttrs: function(tag, sels, elems) {		var buf = [];		var str = sels;		if (str.indexOf(":") != -1) str = str.substring(0, str.indexOf(":"));		var m = str.match(/\[\w+[=~\|\^\$\*]?=?"?[^\]"]*"?\]/g);		var j = -1;		while (++j < elems.length) {			var cur = elems[j].getElementsByTagName(tag);			var k = -1;			while (++k < cur.length) {				var check = true;				var l = -1;				while (++l < m.length) {					var parts = m[l].match(/^\[(\w+)([=~\|\^\$\*]?)=?"?([^\]"]*)"?\]$/);					var an = (parts[1] == "class") ? "className" : parts[1];					var ao = parts[2];					var av = parts[3].replace(/'/g, "");					switch (ao) {						case "=":							if (cur[k][an] != av) check = false;							break;						case "~":							if (!(cur[k][an].match(new RegExp("\\b" + av + "\\b")))) check = false;							break;						case "|":							if (!(cur[k][an].match(new RegExp("^" + av + "-|$")))) check = false;							break;						case "^":							if (!(cur[k][an].match(new RegExp("^" + av)))) check = false;							break;						case "$":							if (!(cur[k][an].match(new RegExp(av + "$")))) check = false;							break;						case "*":							if (!(cur[k][an].indexOf(av) != -1)) check = false;							break;						case "!":							if (!(cur[k][an].indexOf(av) == -1)) check = false;							break;						default:							if (!(cur[k][an])) check = false;					}				}				if (check) buf[buf.length] = cur[k];			}		}		return buf;	},		/**	 * Get elements by pseudo-classes	 * @param {String} part	 * @param {NodeList} elements	 * @param {Node} where	 * @return {NodeList}	 */	getByPseudo: function(part, elements, where) {		if (part.indexOf(":") != -1 && __regs[3].test(part.substring(part.indexOf(":"), part.lastIndexOf("")))) {			var nm = part.substring(0, part.indexOf(":"));			part = part.substring(part.indexOf(":"), part.lastIndexOf(""));			var nopc = part.match(/[a-zA-Z\-]+\(?[a-zA-Z0-9_\.\-\+\*=~\|:\^\$\[\]#"']*\)?/g);			var i = -1;			while (++i < nopc.length) {				var marr = nopc[i].match(__regs[3]);				var buf = [];				var pseudo = marr[1];				var value = marr[2];				switch (pseudo) {					case "first-child":						var j = -1;						while (++j < elements.length) {							if (elements[j].previousSibling) {								var check = true;								var ps = elements[j];								while (ps = ps.previousSibling) {									if (ps.nodeType == 1) {										check = false;										break;									}								}								if (check) buf[buf.length] = elements[j];							} else {								buf[buf.length] = elements[j];							}						}						break;					case "last-child":						var j = -1;						while (++j < elements.length) {							if (elements[j].nextSibling) {								var check = true;								var ns = elements[j];								while (ns = ns.nextSibling) {									if (ns.nodeType == 1) {										check = false;										break;									}								}								if (check) buf[buf.length] = elements[j];							} else {								buf[buf.length] = elements[j];							}						}						break;					case "nth-child":						if (/^\d+|even|odd|(-?\d*)n((\+|\-)(\d+))?$/.test(value)) {							if (value == "even") {								value = "2n";							} else if (value == "odd") {								value = "2n+1";							}							if (/^\d+$/.test(value) && value > 0) {								var j = -1;								while (++j < elements.length) {									var index = 0;									var nc = elements[j].parentNode.firstChild;									while (nc) {										if (nc.nodeType == 1) {											index++;											if (nc == elements[j] && index == value) {												buf[buf.length] = elements[j];												break;											}										}										nc = nc.nextSibling;									}								}							} else if (/^(-?\d*)n((\+|\-)(\d+))?$/.test(value)) {								var val = value.match(/^(-?\d*)n((\+|\-)(\d+))?$/);								var v1 = (val[1] == "-") ? -1 : parseInt(val[1]);	// A/-								var v3 = val[3];									// +/-								var v4 = parseInt(val[4]);							// B								var j = -1;								while (++j < elements.length) {									if (!val[1] && !val[3] && !val[4]) { // n										var nc = elements[j].parentNode.firstChild;										while (nc) {											if (nc.nodeType == 1) {												buf[buf.length] = elements[j];												break;											}											nc = nc.nextSibling;										}									} else if (!!val[1] && !val[3] && !val[4] && v1 > 0) { // An										var index = 1;										var nc = elements[j].parentNode.firstChild;										while (nc) {											if (nc.nodeType == 1) {												if (index % v1 == 0 && nc == elements[j]) {													buf[buf.length] = elements[j];													break;												}												index++;											}											nc = nc.nextSibling;										}									} else if (!val[1] && !!val[3] && !!val[4]) { // n+B										var index = 1;										var nc = elements[j].parentNode.firstChild;										while (nc) {											if (nc.nodeType == 1) {												if (nc == elements[j]) {													if (v3 == "+" && index >= v4) {														buf[buf.length] = elements[j];														break;													} else if (v3 == "-") {														buf[buf.length] = elements[j];														break;													}												}												index++;											}											nc = nc.nextSibling;										}									} else if (!!val[1] && !!val[3] && !!val[4]) { // An+B										var index = 1;										var nc = elements[j].parentNode.firstChild;										while (nc) {											if (nc.nodeType == 1) {												if (nc == elements[j]) {													if (v3 == "+") {														if (v1 < 0) {															if (-index + v4 >= 0) {																buf[buf.length] = elements[j];																break;															}														} else {															if (v1 != 0 && index % v1 == v4) {																buf[buf.length] = elements[j];																break;															} else if (v1 == 0 && index == v4) {																buf[buf.length] = elements[j];																break;															}														}													} else if (v3 == "-") {														if (v1 > 0 && (v4 + index) % v1 == 0) {															buf[buf.length] = elements[j];															break;														}													}												}												index++;											}											nc = nc.nextSibling;										}									}								}							}						}						break;					case "only-child":						var j = -1;						while (++j < elements.length) {							var nc = elements[j].parentNode.firstChild;							var check = false;							var k = 0;							while (nc && !check) {								if (nc.nodeType == 1) {									k++;									if (k > 1) check = true;								}								nc = nc.nextSibling;							}							if (k == 1 && !check) buf[buf.length] = elements[j];						}						break;					case "root":						buf[buf.length] = (elements[j].ownerDocument ? elements[j].ownerDocument : document).documentElement;						break;					case "enabled":						buf = elements;						var k = 0;						while (k < buf.length) {							if (!buf[k].disabled) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "disabled":						buf = elements;						var k = 0;						while (k < buf.length) {							if (buf[k].disabled) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "checked":						buf = elements;						var k = 0;						while (k < buf.length) {							if (buf[k].checked) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "selected":						buf = elements;						var k = 0;						while (k < buf.length) {							if (buf[k].selected) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "empty":						buf = elements;						var k = 0;						while (k < buf.length) {							if (buf[k].childNodes.length == 0) {								k++;							} else {								buf.splice(k, 1);							}						}						break;					case "not":						var badNodes = [];						var t = 0;						var na = [];						if (/^([a-zA-Z0-9*]+)(:[^:]+)*$/.test(value) || /^([a-zA-Z0-9*]+)\.(\w+)(:[^:]+)*$/.test(value)) {							badNodes = QF(where, value);						} else if (/^\.(\w+)(:[^:]+)*$/.test(value) || __regs[2].test(value) || __regs[3].test(value)) {							badNodes = QF(where, nm + value);						}						var k = -1;						while (++k < elements.length) {							var l = -1;							while (++l < badNodes.length) {								if (elements[k] == badNodes[l]) t = 1;							}							if (t == 0) {								na[na.length] = elements[k];							} else {								t = 0;							}						}						buf = na;						break;					case "contains":						var j = -1;						while (++j < elements.length) {							if (elements[j].innerHTML.indexOf(value) != -1) buf[buf.length] = elements[j];						}						break;				}				elements = buf;			}		}		return elements;	},		/**	 * Get elements by combinators	 * @param {String} sels	 * @param {String} qstr	 * @param {Node} where	 * @return {NodeList}	 */	getByCombinators: function(sels, qstr, where) {		var buf = [];		var combinators = sels.match(/>|\+|~/g);		var parts = sels.split(/>|\+|~/);		parts.splice(0, 1);		var cqp = qstr.substring(0, qstr.indexOf(sels) + sels.length);		var searchIn = QF(where, cqp.substring(0, cqp.indexOf(combinators[0], cqp.lastIndexOf(" "))));		var j = -1;		while (++j < parts.length) {			var searchFor = QF(where, parts[j]);			switch (combinators[j]) {				case ">":					var k = -1;					while (++k < searchIn.length) {						var l = -1;						while (++l < searchFor.length) {							if (searchFor[l].parentNode == searchIn[k]) buf[buf.length] = searchFor[l];						}					}					return buf;					break;				case "+":					var k = -1;					while (++k < searchFor.length) {						var l = -1;						while (++l < searchIn.length) {							var ns = searchIn[l];							while ((ns = ns.nextSibling) && ns.nodeType != 1) {}							if (ns == searchFor[k]) {								buf[buf.length] = searchFor[k];								break;							}						}					}					return buf;					break;				case "~":					var k = -1;					while (++k < searchFor.length) {						var l = -1;						while (++l < searchIn.length) {							if (searchFor[k].parentNode == searchIn[l].parentNode) {								if (nodeIndex(searchFor[k]) > nodeIndex(searchIn[l])) {									buf[buf.length] = searchFor[k];									break;								}							}						}					}					return buf;					break;			}		}	}};})();/** * Initialize Carbon.JS */CarbonJS.init();/** * Add method "forEach" for elements */CarbonJS.extend({	forEach: function(func) {		var e = -1;		while (++e < this.length) func.apply(this[e], [e]);		return this;	}});